

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Factotum Documentation classes/ticket.js</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="jsdoc-styles.css">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">Factotum Discord Bot Documentation</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                 
                    
                        <a
                            class="link user-link "
                            href="https://github.com/nwplus/Factotum"
                        >
                            Github
                        </a>
                    
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
                <div class="search-wrapper">
                    <input id="search" type="text" placeholder="Search docs..." class="input">
                </div>
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Modules</h3><ul><li><a href="module-DiscordServices.html">DiscordServices</a></li><li><a href="module-FirebaseParser.html">FirebaseParser</a></li><li><a href="module-FirebaseServices.html">FirebaseServices</a></li><li><a href="module-MainApp.html">MainApp</a></li><li><a href="module-MongoUtil.html">MongoUtil</a></li></ul><h3>Classes</h3><ul><li><a href="Activity.html">Activity</a></li><li><a href="BotGuild.html">BotGuild</a></li><li><a href="Cave.html">Cave</a></li><li><a href="CoffeeChats.html">CoffeeChats</a></li><li><a href="PermissionCommand.html">PermissionCommand</a></li><li><a href="Prompt.html">Prompt</a></li><li><a href="StampsManager.html">StampsManager</a></li><li><a href="Team.html">Team</a></li><li><a href="TeamFormation.html">TeamFormation</a></li><li><a href="Verification.html">Verification</a></li><li><a href="Workshop.html">Workshop</a></li></ul><h3><a href="global.html">Global</a></h3></div><div class="category"><h2>Commands</h2><h3>Classes / Hacker-Utility</h3><ul><li><a href="AskQuestion.html">AskQuestion</a></li><li><a href="Report.html">Report</a></li></ul><h3>Classes / Verification</h3><ul><li><a href="Attend.html">Attend</a></li><li><a href="CheckMember.html">CheckMember</a></li><li><a href="ManualVerify.html">ManualVerify</a></li><li><a href="module.exports.html">exports</a></li><li><a href="StartAttend.html">StartAttend</a></li><li><a href="Verify.html">Verify</a></li></ul><h3>Classes / Stamps</h3><ul><li><a href="ChangeStampTime.html">ChangeStampTime</a></li><li><a href="PasswordStamp.html">PasswordStamp</a></li><li><a href="Raffle.html">Raffle</a></li></ul><h3>Classes / Admin-Utility</h3><ul><li><a href="ClearChat.html">ClearChat</a></li><li><a href="Pronouns.html">Pronouns</a></li><li><a href="RoleSelector.html">RoleSelector</a></li><li><a href="SelfCareReminders.html">SelfCareReminders</a></li></ul><h3>Classes / Activity</h3><ul><li><a href="DiscordContests.html">DiscordContests</a></li><li><a href="NewActivity.html">NewActivity</a></li><li><a href="NewCoffeeChats.html">NewCoffeeChats</a></li><li><a href="NewWorkshop.html">NewWorkshop</a></li></ul><h3>Classes / Boothing</h3><ul><li><a href="ERoomDirectory.html">ERoomDirectory</a></li></ul><h3>Classes / Essentials</h3><ul><li><a href="Help.html">Help</a></li><li><a href="InitBot.html">InitBot</a></li><li><a href="UnknownCommand.html">UnknownCommand</a></li></ul><h3>Classes / Start-Commands</h3><ul><li><a href="StartChannelCreation.html">StartChannelCreation</a></li><li><a href="StartMentorCave.html">StartMentorCave</a></li><li><a href="StartTeamFormation.html">StartTeamFormation</a></li><li><a href="StartTeamRoulette.html">StartTeamRoulette</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>classes/ticket.js</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const { Collection, GuildEmoji, ReactionEmoji, Guild, CategoryChannel, TextChannel, VoiceChannel, User, Message, MessageEmbed, Snowflake, } = require("discord.js");
const winston = require("winston");
const { sendEmbedToMember, deleteChannel } = require('../discord-services');
const Cave = require("./cave");

class Ticket {
    /**
    * @typedef Emojis
    * @property {GuildEmoji | ReactionEmoji} joinTicketEmoji - emoji for mentors to accept a ticket
    * @property {GuildEmoji | ReactionEmoji} giveHelpEmoji - emoji for mentors to join an ongoing ticket
    * @property {GuildEmoji | ReactionEmoji} requestTicketEmoji - emoji for hackers to request a ticket
    * @property {GuildEmoji | ReactionEmoji} addRoleEmoji - emoji for Admins to add a mentor role
    * @property {GuildEmoji | ReactionEmoji} deleteChannelsEmoji - emoji for Admins to force delete ticket channels
    * @property {GuildEmoji | ReactionEmoji} excludeFromAutoDeleteEmoji - emoji for Admins to opt tickets in/out of garbage collector
    */

    constructor(guild, question, cave, requester, hackers, ticketNumber, ticketMsg, inactivePeriod, bufferTime) {
        /**
         * Guild this ticket is in
         * @type {Guild}
         */
        this.guild = guild;

        /**
         * Category this ticket's voice and text channels are under
         * @type {CategoryChannel}
         */
        this.category;

        /**
         * Question from hacker
         * @type {String}
         */
        this.question = question;

        /**
         * Text channel for this ticket
         * @type {TextChannel}
         */
        this.text;

        /**
         * Voice channel for this ticket
         * @type {VoiceChannel}
         */
        this.voice;

        /**
         * The cave this ticket is in
         * @type {Cave}
         */
        this.cave = cave;

        /**
         * Emojis used in the cave this ticket is in
         * @type {Emojis}
         */
        this.caveEmojis = cave.caveOptions.emojis;

        /**
         * User who requested the ticket
         * @type {User}
         */
        this.requester = requester;

        /**
         * Users(teammates) mentioned in the question
         * @type {Array&lt;User>}
         */
        this.hackers = hackers;
        /**
         * Mentors who join the ticket
         * @type {Array&lt;User>}
         */
        this.mentors = [];

        /**
         * Ticket number
         * @type {Number}
         */
        this.ticketNumber = ticketNumber;

        /**
         * Bot message containing information sent to ticket text channel
         * @type {MessageEmbed}
         */
        this.openTicketEmbed = new MessageEmbed()
            .setColor(this.cave.botGuild.colors.embedColor)
            .setTitle('Original Question')
            .setDescription('&lt;@' + this.requester.id + '> has the question: ' + this.question);

        /**
         * The message with the information embed sent to the ticket channel.
         * @type {Message}
         */
        this.openTicketEmbedMsg;

        /**
         * Message sent to incoming ticket channel
         * @type {Message} 
         */
        this.ticketMsg = ticketMsg;

        /**
         * Amount of time, in minutes, of inactivity in the ticket text channel before the bot initiates ticket deletion sequence
         * @type {Number} 
         */
        this.inactivePeriod = inactivePeriod;

        /**
         * Amount of time, in minutes, the bot will wait for a response after asking to delete a ticket
         * @type {Number}
         */
        this.bufferTime = bufferTime;

        /**
         * Interval ID for setInterval and clearInterval functions
         * @type {Number}
         */
        this.interval;

        /**
         * Flag to check if a deletion sequence has already been triggered by all mentors leaving the ticket; if so, there will not be
         * another sequence started for inactivity
         * @type {Boolean}
         */
        this.mentorDeletionSequence = false;

        /**
         * Flag for whether this ticket is excluded from automatic garbage collection
         * @type {Boolean}
         */
        this.excluded = false;

        this.init();
    }
    /**
     * This function is called by the ticket's Cave class to change its status between include/exclude for automatic garbage collection.
     * If a previously excluded ticket is re-included, the bot starts listening for inactivity as well.
     * @param {Boolean} exclude - true if ticket is now excluded from garbage collection, false if not
     */
    async includeExclude(exclude) {
        // oldExclude saves the previous inclusion status of the ticket
        var oldExclude = this.excluded;
        // set excluded variable to new status
        this.excluded = exclude;

        // if this ticket was previously excluded and is now included, start the listener for inactivity
        if (oldExclude &amp;&amp; !exclude) {
            this.createActivityListener();
        }
    }

    /**
     * Create a category with the ticket's number, and a voice and text channel under it
     */
    async createCategory() {
        this.category = await this.guild.channels.create("Ticket - " + this.ticketNumber, {
            type: 'category',
            permissionOverwrites: [
                {
                    id: this.cave.botGuild.roleIDs.everyoneRole,
                    deny: ['VIEW_CHANNEL'],
                }
            ]
        });

        this.text = await this.guild.channels.create('banter', {
            type: 'text',
            parent: this.category
        });

        this.voice = await this.guild.channels.create('discussion', {
            type: 'voice',
            parent: this.category
        });
    }

    async init() {

        /**
         * @type {Collection&lt;Snowflake, GuildEmoji>} - &lt;guild emoji snowflake, guild emoji>
         */
        const ticketEmojis = new Collection();
        ticketEmojis.set(this.caveEmojis.giveHelpEmoji.name, this.caveEmojis.giveHelpEmoji);

        // permissions for users that will be added into the ticket category
        let ticketPermissions = { 'VIEW_CHANNEL': true, 'USE_VAD': true };

        // reaction collector that listens for the emojis that trigger actions
        const ticketCollector = this.ticketMsg.createReactionCollector((reaction, user) => !user.bot &amp;&amp; ticketEmojis.has(reaction.emoji.name));

        // if ticket has not been accepted after the specified time, it will send a reminder to the incoming tickets channel tagging all mentors
        var timeout = setTimeout(() => {
            this.cave.privateChannels.incomingTickets.send('Hello &lt;@&amp;' + this.cave.caveOptions.role + '> ticket number ' + this.ticketNumber + ' still needs help!');
        }, this.cave.caveOptions.times.reminderTime * 60 * 1000);

        // let user know that ticket was submitted and give option to remove ticket
        let removeTicketEmoji = 'âš”ï¸';

        let reqTicketUserEmbedMsg = await sendEmbedToMember(this.requester, {
            title: 'Ticket was Successful!',
            description: 'Your ticket to the ' + this.cave.caveOptions.name + ' group was successful! It is ticket number ' + this.ticketNumber + '.',
            fields: [{
                title: 'Remove the ticket',
                description: 'If you don\'t need help anymore, react to this message with ' + removeTicketEmoji,
            },
            {
                title: 'Ticket Description:',
                description: this.question,
            }]
        });

        reqTicketUserEmbedMsg.react(removeTicketEmoji);
        let reqTicketUserEmbedMsgCollector = reqTicketUserEmbedMsg.createReactionCollector((reaction, user) => !user.bot &amp;&amp; reaction.emoji.name === removeTicketEmoji, { max: 1 });
        reqTicketUserEmbedMsgCollector.on('collect', (reaction, user) => {
            // don't allow anyone to join ticket and update dm with user to show that ticket has been canceled
            ticketCollector.stop();
            this.ticketMsg.edit(this.ticketMsg.embeds[0].setColor('#128c1e').addField('Ticket Closed', 'This ticket has been closed by the user!'));
            reqTicketUserEmbedMsg.delete({ timeout: 3000 });
            sendEmbedToMember(user, {
                title: 'Ticket Closed!',
                description: 'Your ticket number ' + this.ticketNumber + ' has been closed!',
            }, true);
            this.cave.tickets.delete(this.ticketNumber); // delete from cave's list of active tickets
            clearTimeout(timeout);
        });

        ticketCollector.on('collect', async (reaction, helper) => {
            if (reaction.emoji.name === this.caveEmojis.joinTicketEmoji.name) {
                // add new mentor to existing ticket channels
                await this.category.updateOverwrite(helper, ticketPermissions);
                this.text.send('&lt;@' + helper.id + '> Has joined the ticket!').then(msg => msg.delete({ timeout: 10000 }));
                this.mentors.push(helper.id); //add new mentor to list of mentors

                this.ticketMsg.edit(this.ticketMsg.embeds[0].addField('More hands on deck!', '&lt;@' + helper.id + '> Joined the ticket!'));
                this.openTicketEmbedMsg.edit(this.openTicketEmbedMsg.embeds[0].addField('More hands on deck!', '&lt;@' + helper.id + '> Joined the ticket!'));
            } else {
                clearTimeout(timeout);
                // edit incoming ticket with mentor information
                this.ticketMsg.edit(this.ticketMsg.embeds[0].addField('This ticket is being handled!', '&lt;@' + helper.id + '> Is helping this team!')
                    .addField('Still want to help?', 'Click the ' + this.caveEmojis.joinTicketEmoji.toString() + ' emoji to join the ticket!')
                    .setColor('#80c904'));
                this.ticketMsg.react(this.caveEmojis.joinTicketEmoji);
                ticketEmojis.delete(this.caveEmojis.giveHelpEmoji.name);
                ticketEmojis.set(this.caveEmojis.joinTicketEmoji.name, this.caveEmojis.joinTicketEmoji);

                // update dm with user to reflect that their ticket has been accepted
                const openedTicketEmbed = new MessageEmbed()
                    .setColor('#128c1e')
                    .setTitle('Your Ticket Number ' + this.ticketNumber + ' Has Been Opened!')
                    .setDescription('Your question: ' + this.question + '\nPlease go to the corresponding channel and read the instructions there.')
                reqTicketUserEmbedMsg.edit(openedTicketEmbed);
                reqTicketUserEmbedMsgCollector.stop();

                // new ticket, create channels and add users
                await this.createCategory();
                await this.category.updateOverwrite(helper, ticketPermissions);
                this.hackers.forEach(user => this.category.updateOverwrite(user, ticketPermissions));

                let leaveTicketEmoji = 'ðŸ‘‹ðŸ½';
                this.openTicketEmbed.addField('Thank you for helping this team.', '&lt;@' + helper.id + '> Best of luck!')
                    .addField('When done:', '* React to this message with ' + leaveTicketEmoji + ' to lose access to these channels!');

                // send message with information embed to the ticket text channel
                this.openTicketEmbedMsg = await this.text.send(this.openTicketEmbed);
                this.openTicketEmbedMsg.react(leaveTicketEmoji);
                this.mentors.push(helper.id);

                // send message mentioning all the parties involved so they get a notification
                let notificationMessage = '&lt;@' + helper.id + '> ' + this.hackers.join(' ');
                this.text.send(notificationMessage).then(msg => msg.delete({ timeout: 15000 }));

                this.createActivityListener(); //create a listener for inactivity in the text channel

                // reaction collector that listens for the emoji to leave a ticket
                const looseAccessCollector = this.openTicketEmbedMsg.createReactionCollector((reaction, user) => !user.bot &amp;&amp; reaction.emoji.name === leaveTicketEmoji);

                looseAccessCollector.on('collect', async (reaction, exitUser) => {
                    // if mentor is leaving, delete from mentors list
                    for (var i = 0; i &lt; this.mentors.length; i++) {
                        if (this.mentors[i] === exitUser.id) {
                            this.mentors.splice(i, 1);
                        }
                    }

                    // if hacker is leaving, delete from hackers list
                    for (var i = 0; i &lt; this.hackers.length; i++) {
                        if (this.hackers[i] === exitUser) {
                            this.hackers.splice(i, 1);
                        }
                    }

                    // if all hackers are gone, delete ticket channels
                    if (this.hackers.length === 0) {
                        ticketCollector.stop();
                        looseAccessCollector.stop();
                        this.ticketMsg.edit(this.ticketMsg.embeds[0].setColor('#128c1e').addField('Ticket Closed', 'This ticket has been closed!! Good job!'));
                        await deleteChannel(this.voice);
                        await deleteChannel(this.text);
                        await deleteChannel(this.category);
                        this.cave.tickets.delete(this.ticketNumber); // delete this ticket from the cave's Collection of active tickets
                    } else if (this.mentors.length === 0) {
                        this.category.updateOverwrite(exitUser, { VIEW_CHANNEL: false, SEND_MESSAGES: false, READ_MESSAGE_HISTORY: false });
                        // tell hackers mentor is gone and ask to delete the ticket if this has not been done already 
                        if (!this.mentorDeletionSequence &amp;&amp; !this.excluded) {
                            this.mentorDeletionSequence = true;
                            await this.askToDelete('mentor');
                            ticketCollector.stop();
                            // if none of the channels has been deleted (i.e. someone responded to the request to delete the channel by
                            // asking for more time) then set an interval to check in again later
                            if (!this.category.deleted &amp;&amp; !this.text.deleted &amp;&amp; !this.voice.deleted) {
                                this.interval = setInterval(() => this.askToDelete('mentor'), this.inactivePeriod * 60 * 1000);
                            }
                        }
                    } else {
                        //change user permissions so that they no longer have access
                        this.category.updateOverwrite(exitUser, { VIEW_CHANNEL: false, SEND_MESSAGES: false, READ_MESSAGE_HISTORY: false });
                    }
                });
            }
        });
    }

    /**
     * Main deletion sequence: mentions and asks hackers if ticket can be deleted, and deletes if there is no response or indicates that
     * it will check in again later if someone does respond
     * @param {String} reason - 'mentor' if this deletion sequence was initiated by the last mentor leaving, 'inactivity' if initiated by
     * inactivity in the text channel 
     */
    async askToDelete(reason) {
        // if ticket is missing a channel it does not start the sequence in case another deletion sequence is ongoing; also does not 
        // initiate if ticket is currently excluded from garbage collection
        if (this.category.deleted || this.text.deleted || this.voice.deleted || this.excluded) return;

        // assemble message to send to hackers to verify if they still need the ticket
        var requestMsg = this.hackers.join(' ');
        if (reason === 'inactivity') {
            requestMsg = requestMsg + ' &lt;@' + this.mentors.join('> &lt;@') + '>'
            requestMsg = requestMsg + ' Hello! I detected some inactivity on this channel and wanted to check in.\n';
        } else if (reason === 'mentor') {
            requestMsg = requestMsg + ' Hello! Your mentor(s) has/have left the ticket.\n'
        }
        let warning = await this.text.send(requestMsg + 'If the ticket has been solved, please click the ðŸ‘‹ emoji above to leave the channel. ' +
            'If you need to keep the channel, please click the emoji below, **otherwise this ticket will be deleted in ** ' + this.bufferTime + ' **minutes**.')

        await warning.react('ðŸ”„');

        // reaction collector to listen for someone to react with the emoji for more time
        const deletionCollector = warning.createReactionCollector((reaction, user) => !user.bot &amp;&amp; reaction.emoji.name === 'ðŸ”„', { time: this.bufferTime * 60 * 1000, max: 1 });
        deletionCollector.on('end', async (collected) => {
            // if a channel has already been deleted by another process, stop this deletion sequence
            if (this.category.deleted || this.text.deleted || this.voice.deleted) {
                clearInterval(this.interval);
            } else if (collected.size === 0 &amp;&amp; !this.excluded) { // checks to see if no one has responded and this ticket is not exempt
                clearInterval(this.interval);

                // delete channels, update Cave's ticket Collection and edit message in incoming tickets if there is no other 
                // deletion process ongoing
                if (!this.category.deleted &amp;&amp; !this.text.deleted &amp;&amp; !this.voice.deleted) {
                    await deleteChannel(this.voice);
                    await deleteChannel(this.text);
                    await deleteChannel(this.category);
                    this.ticketMsg.edit(this.ticketMsg.embeds[0].setColor('#128c1e').addField('Ticket Closed Due to Inactivity', 'This ticket has been closed!! Good job!'));
                    sendEmbedToMember(this.requester, {
                        title: 'Ticket Closed!',
                        description: 'Your ticket number ' + this.ticketNumber + ' was closed due to inactivity. If you need more help, please request another ticket!',
                    }, false);
                    this.cave.tickets.delete(this.ticketNumber);
                }
            } else if (collected.size > 0) {
                await this.text.send('You have indicated that you need more time. I\'ll check in with you later!');
            }
        });
    }

    /**
     * Listen for inactivity on the text channel
     */
    async createActivityListener() {
        // stop listening if there is another deletion process ongoing
        if (this.category.deleted || this.text.deleted || this.voice.deleted || this.excluded) return;
        // message collector that stops when there are no messages for inactivePeriod minutes
        const activityListener = this.text.createMessageCollector(m => !m.author.bot, { idle: this.inactivePeriod * 60 * 1000 });
        activityListener.on('end', async collected => {
            //don't start deletion sequence if the text/voice channel got deleted while the collector was listening
            if (!this.mentorDeletionSequence &amp;&amp; !this.category.deleted &amp;&amp; !this.text.deleted &amp;&amp; !this.voice.deleted) {
                if (this.voice.members.array().length === 0) {
                    await this.askToDelete('inactivity');
                }
                this.createActivityListener(); // start listening again for inactivity if they asked for more time
            }
        });
    }
}

module.exports = Ticket;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

<script src="scripts/search.js"> </script>

</body>
</html>
